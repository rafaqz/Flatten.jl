<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flatten.jl · Flatten.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Flatten.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Flatten.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Flatten.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Flatten.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rafaqz/Flatten.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Flatten.jl"><a class="docs-heading-anchor" href="#Flatten.jl">Flatten.jl</a><a id="Flatten.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Flatten.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Flatten.Flatten" href="#Flatten.Flatten"><code>Flatten.Flatten</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>Flatten</strong></p><p><a href="https://rafaqz.github.io/Flatten.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://rafaqz.github.io/Flatten.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://travis-ci.org/rafaqz/Flatten.jl"><img src="https://travis-ci.org/rafaqz/Flatten.jl.svg?branch=master" alt="Build Status"/></a> <a href="http://codecov.io/github/rafaqz/Flatten.jl?branch=master"><img src="http://codecov.io/github/rafaqz/Flatten.jl/coverage.svg?branch=master" alt="codecov.io"/></a> <a href="https://coveralls.io/github/rafaqz/Flatten.jl?branch=master"><img src="https://coveralls.io/repos/rafaqz/Flatten.jl/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a></p><p>Flatten.jl converts data from arbitrary nested structs to tuples, using <code>flatten()</code>, and rebuilds them using <code>reconstruct()</code>, <code>update!()</code>.  <code>modify()</code> combines <code>flatten</code> and <code>reconstruct</code> with a function application to each element of the intermediate tuple. </p><p>This facilitates building modular, composable structs that can be queries, modified and rebuilt based on the types of their fields, without knowing field locations.</p><p>It also allows access to solvers and optimisers that require flat lists of parameters.  Importantly, it&#39;s type-stable and <em>very</em> fast. It does not flatten the contents of Array or Dict (which is a container of Arrays), where the number of values are not known at compile time. </p><p>Flatten is also flexible. The types to return and ignore can be specified, and individual fields can be ignored using field-level traits like <code>flattenable</code> from FieldMetadata.jl. Method overrides can also be defined for custom types.</p><p><strong>Type queries</strong></p><p>Flatten allows a kind of querying to extract some types and ignore others, here using <code>flatten</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; struct Bar{X}
           x::X
       end

julia&gt; obj = Foo(1, :two, Foo(Bar(3), 4.0, 5.0f0));

julia&gt; use = Union{Int, Float32}; # Return Int and Float32 fields

julia&gt; ignore = Bar;              # Dont return Bar or iterate over Bar fields

julia&gt; flatten(obj, use, ignore)  # `flatten` all Int and Float32 except fields of Bar
(1, 5.0f0)

julia&gt; modify(string, obj, Int)   # `modify`: convert all Int to String
Foo{String,Symbol,Foo{Bar{String},Float64,Float32}}(&quot;1&quot;, :two, Foo{Bar{String},Float64,Float32}(Bar{String}(&quot;3&quot;), 4.0, 5.0f0))</code></pre><p>The default type used is <code>Real</code>. These rules also apply in <code>reconstruct</code>, <code>update!</code> and <code>modify</code>.</p><p><strong>Field removal</strong></p><p>There are often cases where you want to ignore certain fields that have the same type as the fields you want to extract. Flatten.jl also <a href="https://github.com/rafaqz/FieldMetadata.jl">FieldMetadata.jl</a> to provide <code>@flattenable</code> macro and methods, allowing you to choose fields to include and remove from flattening. The default is <code>true</code> for all fields.</p><pre><code class="language-julia hljs">using Flatten
import Flatten: flattenable

@flattenable struct Bar{X,Y}
    x::X | true
    y::Y | false
end

flatten(Bar(1, 2))

# output
(1,)</code></pre><p>Custom <code>@metadata</code> methods from FieldMetadata can be used, if they return a Bool. You can also use custom functions that follow the following form, returning a boolean:</p><pre><code class="language-julia hljs">f(::Type, ::Type{Var{:fieldname}}) = false</code></pre><p><strong>Metatdata flattening</strong></p><p>Flatten also provides <code>metaflatten()</code> to flatten any FieldMetadata.jl metadata for the same fields <code>flatten()</code> returns. This can be useful for attaching information like descriptions or prior probability distributions to each field. Regular field data can also be collected with convenience versions of metaflatten: <code>fieldnameflatten</code>, <code>parentflatten</code>, <code>fieldtypeflatten</code> and <code>parenttypeflatten</code> functions provide lists of fieldnames and types that may be useful for building parameter display tables.</p><p>This package was started by Robin Deits (@rdeits), and its early development owes much to discussions and ideas from Jan Weidner (@jw3126) and Robin Deits. &quot;&quot;&quot;</p><p><strong><code>reconstruct</code> and <code>modify</code> for StaticArrays</strong></p><p><code>SArray</code> and other objects from StaticArrays.jl can not be constructed from their fields.  Dealing with this in the long term will require either a dependency on ConstructionBase.jl in StaticArrays.jl, or a glue package that provides the required <code>constructorof</code> methods, which for now you can define manually:</p><pre><code class="language-julia hljs">using StaticArrays, ConstructionBase, Flatten

struct SArrayConstructor{S,N,L} end
(::SArrayConstructor{S,N,L})(data::NTuple{L,T}) where {S,T,N,L} = SArray{S,T,N,L}(data)

ConstructionBase.constructorof(sa::Type{&lt;:SArray{S,&lt;:Any,N,L}}) where {S,N,L} = 
    SArrayConstructor{S,N,L}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L4-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.fieldnameflatten-Tuple{Any, Vararg{Any, N} where N}" href="#Flatten.fieldnameflatten-Tuple{Any, Vararg{Any, N} where N}"><code>Flatten.fieldnameflatten</code></a> — <span class="docstring-category">Method</span></header><section><div><p>jldoctest     fieldnameflatten(obj, args...)</p><p>Flatten the field names of an object. Args are passed to <a href="#Flatten.metaflatten"><code>metaflatten</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; fieldnameflatten(Foo(1, 2, 3))
(:a, :b, :c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L410-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.fieldtypeflatten-Tuple{Any, Vararg{Any, N} where N}" href="#Flatten.fieldtypeflatten-Tuple{Any, Vararg{Any, N} where N}"><code>Flatten.fieldtypeflatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldtypeflatten(obj, args...)</code></pre><p>Flatten the field types of an object. Args are passed to <a href="#Flatten.metaflatten"><code>metaflatten</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; fieldtypeflatten(Foo(1.0, :two, &quot;Three&quot;), Union{Real,String})
(Float64, String)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L435-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.flatten" href="#Flatten.flatten"><code>Flatten.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flatten(obj, [flattentrait::Function], [use::Type], [ignore::Type])</code></pre><p>Flattening. Flattens a nested struct or tuple to a flat tuple. Query types and flatten trait arguments are optional, but you must pass <code>use</code> to pass <code>ignore</code>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: The target type to be reconstructed</li><li><code>flattentrait</code>: A function returning a Bool, such as a FielMetadata method. With the form: <code>f(::Type, ::Type{Val{:fieldname}}) = true</code></li><li><code>use</code>: Type or <code>Union</code> of types to return in the tuple.</li><li><code>ignore</code>: Types or <code>Union</code> of types  to ignore completly. These are not reurned or recursed over.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; foo = Foo(1, 2, 3)
Foo{Int64,Int64,Int64}(1, 2, 3)

julia&gt; flatten(foo)
(1, 2, 3)

julia&gt; nested = Foo(Foo(1, 2, 3), 4.0, 5.0)
Foo{Foo{Int64,Int64,Int64},Float64,Float64}(Foo{Int64,Int64,Int64}(1, 2, 3), 4.0, 5.0)

julia&gt; flatten(nested)
(1, 2, 3, 4.0, 5.0)

To convert the tuple to a vector, simply use [flatten(x)...], or
using static arrays to avoid allocations: `SVector(flatten(x))`.</code></pre><p>Fields can be excluded from flattening with the <code>flattenable(struct, field)</code> method. These are easily defined using <code>@flattenable</code> from <a href="https://github.com/rafaqz/FieldMetadata.jl">FieldMetadata.jl</a>, or defining your own custom function with FieldMetadata, or manually with the form:</p><pre><code class="language-julia hljs">julia&gt; import Flatten: flattenable

julia&gt; @flattenable struct Partial{A,B,C}
           a::A | true
           b::B | true
           c::C | false
       end

julia&gt; nestedpartial = Partial(Partial(1.0, 2.0, 3.0), 4, 5)
Partial{Partial{Float64,Float64,Float64},Int64,Int64}(Partial{Float64,Float64,Float64}(1.0, 2.0, 3.0), 4, 5)

julia&gt; nestedpartial = Partial(Partial(1.0, 2.0, 3.0), 4, 5)
Partial{Partial{Float64,Float64,Float64},Int64,Int64}(Partial{Float64,Float64,Float64}(1.0, 2.0, 3.0), 4, 5)

julia&gt; flatten(nestedpartial)
(1.0, 2.0, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L38-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.metaflatten" href="#Flatten.metaflatten"><code>Flatten.metaflatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">metaflatten(obj, func, [flattentrait::Function], [use::Type], [ignore::Type])</code></pre><p>Metadata flattening. Flattens data attached to a field using a passed in function Query types and flatten trait arguments are optional, but you must pass <code>use</code> to pass <code>ignore</code>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: The target type to be reconstructed</li><li><code>func</code>: A function with the form: <code>f(::Type, ::Type{Val{:fieldname}}) = metadata</code></li><li><code>flattentrait</code>: A function returning a Bool, such as a FielMetadata method. With the form: <code>f(::Type, ::Type{Val{:fieldname}}) = true</code></li><li><code>use</code>: Type or <code>Union</code> of types to return in the tuple.</li><li><code>ignore</code>: Types or <code>Union</code> of types  to ignore completly. These are not reurned or recursed over.</li></ul><p>We can flatten this <code>@foobar</code> metadata:</p><pre><code class="language-julia-repl hljs">julia&gt; using Flatten, FieldMetadata

julia&gt; import Flatten: flattenable

julia&gt; @metadata foobar :foo;

julia&gt; @foobar struct Foo{A,B,C}
           a::A | :bar
           b::B | :foobar
           c::C | :foo
       end;

julia&gt; @foobar struct Bar{X,Y}
           x::X | :foobar
           y::Y | :bar
       end;

julia&gt; metaflatten(Foo(1, 2, Bar(3, 4)), foobar)
(:bar, :foobar, :foobar, :bar)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L338-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.modify-Tuple{Any, Any, Vararg{Any, N} where N}" href="#Flatten.modify-Tuple{Any, Any, Vararg{Any, N} where N}"><code>Flatten.modify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modify(func, obj, args...)</code></pre><p>Modify field in a type with a function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.parentnameflatten-Tuple{Any, Vararg{Any, N} where N}" href="#Flatten.parentnameflatten-Tuple{Any, Vararg{Any, N} where N}"><code>Flatten.parentnameflatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parentnameflatten(obj, args...)</code></pre><p>Flatten the name of the parent type of an object. Args are passed to <a href="#Flatten.metaflatten"><code>metaflatten</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; struct Bar{X,Y}
           x::X
           y::Y
       end

julia&gt; parentnameflatten(Foo(1, 2, Bar(3, 4)))
(:Foo, :Foo, :Bar, :Bar)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L461-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.parenttypeflatten-Tuple{Any, Vararg{Any, N} where N}" href="#Flatten.parenttypeflatten-Tuple{Any, Vararg{Any, N} where N}"><code>Flatten.parenttypeflatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parenttypeflatten(obj, args...)</code></pre><p>Flatten the parent type of an object. Args are passed to <a href="#Flatten.metaflatten"><code>metaflatten</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Flatten

julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; struct Bar{X,Y}
           x::X
           y::Y
       end

julia&gt; parenttypeflatten(Foo(1, 2, Bar(3, 4)))
(Foo{Int64,Int64,Bar{Int64,Int64}}, Foo{Int64,Int64,Bar{Int64,Int64}}, Bar{Int64,Int64}, Bar{Int64,Int64})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L491-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.reconstruct" href="#Flatten.reconstruct"><code>Flatten.reconstruct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reconstruct(obj, data, [flattentrait::Function], [use::Type], [ignore::Type])</code></pre><p>Reconstruct an object from Tuple or Vector data and an existing object. Data should be at least as long as the queried fields in the obj. Query types and flatten trait arguments are optional, but you must pass <code>use</code> to pass <code>ignore</code>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: The target type to be reconstructed</li><li><code>data</code>: Replacement data - an <code>AbstractArray</code>, <code>Tuple</code> or type that defines <code>getfield</code>.</li><li><code>flattentrait</code>: A function returning a Bool, such as a FielMetadata method. With the form: <code>f(::Type, ::Type{Val{:fieldname}}) = true</code></li><li><code>use</code>: Type or <code>Union</code> of types to return in the tuple.</li><li><code>ignore</code>: Types or <code>Union</code> of types  to ignore completly. These are not reurned or recursed over.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; struct Foo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; reconstruct(Foo(1, 2, 3), (1, :two, 3.0))
Foo{Int64,Symbol,Float64}(1, :two, 3.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L137-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Flatten.update!" href="#Flatten.update!"><code>Flatten.update!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update!(obj, data, [flattentrait::Function], [use::Type], [ignore::Type])</code></pre><p>Update a mutable object with a <code>Tuple</code> or <code>Vector</code> of data. Query types and flatten trait arguments are optional, but you must pass <code>use</code> to pass <code>ignore</code>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: The target type to be reconstructed</li><li><code>data</code>: Replacement data - an <code>AbstractArray</code>, <code>Tuple</code> or type that defines <code>getfield</code>.</li><li><code>flattentrait</code>: A function returning a Bool, such as a FielMetadat method. With the form: <code>f(::Type, ::Type{Val{:fieldname}}) = true</code></li><li><code>use</code>: Types to return in the tuple.</li><li><code>ignore</code>: Types to ignore completly. These are not reurned or recursed over.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Flatten

julia&gt; mutable struct MutableFoo{A,B,C}
           a::A
           b::B
           c::C
       end

julia&gt; mufoo = MutableFoo(1, 2, 3)
MutableFoo{Int64,Int64,Int64}(1, 2, 3)

julia&gt; update!(mufoo, (2, 4, 6))
MutableFoo{Int64,Int64,Int64}(2, 4, 6)

julia&gt; mufoo = MutableFoo(1, 2, :three)
MutableFoo{Int64,Int64,Symbol}(1, 2, :three)

julia&gt; update!(mufoo, (:foo,), Symbol)
MutableFoo{Int64,Int64,Symbol}(1, 2, :foo)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/Flatten.jl/blob/f950258e867bf06f8893f805ca4262eb22770af1/src/Flatten.jl#L254-L292">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Monday 4 October 2021 10:27">Monday 4 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
